// Based on https://github.com/yuanchuan/node-watch
'use strict';
var fs = require('fs')
var path = require('path')

var isArray = Array.isArray
var reduce = Array.prototype.reduce
var isFile = isType.bind(null, 'File')
var isDir = isType.bind(null, 'Directory')
var isSym = isType.bind(null, 'SymbolicLink')

// Remember files and directories
var memo = {
  _cache: {},
  push: function (name) {
    this._cache[name] = true
  },
  has: function (name) {
    return this._cache.hasOwnProperty(name)
  },
  update: function (name) {
    if (!isFile(name) || !isDir(name))
      delete this._cache[name]
    return true
  }
}

// Remember filenames
var fileNameCache = {
  _cache: {},
  push: function addFileName(name) {
    this._cache[name] = true
  },
  clear: function forEachFileName(iterator) {
    Object.keys(this._cache).filter(byFile).forEach(iterator)
    this._cache = {}
  }
}

function byFile(name) {
  return isFile(name) || memo.has(name) && memo.update(name)
}

// See https://lodash.com/docs#assign
function assign() {
  return reduce.call(arguments, function (dest, src) {
    for (var key in src) if (src.hasOwnProperty(key))
      dest[key] = src[key]
    return dest
  })
}

function isType(type, src) {
  var stat = (type === 'SymbolicLink' ? fs.lstatSync : fs.statSync)
  if (fs.existsSync(src)) {
    memo.push(src)
    return stat(src)['is' + type]()
  }
  return false
}

function runExclusive(job) {
  function done() { runExclusive._mx = false }
  if (!runExclusive._mx) {
    runExclusive._mx = true
    // A heuristic delay of the write-to-file process
    setTimeout(job.bind(null, done), 100)
  }
}

/**
 * Get immediate subdirectories
 * @param {string} base
 * @param {function} callback Invoked for each directory
 */
function getSubdirs(base, callback) {
  if (isDir(base)) fs.readdir(base, function (err, all) {
    if (all) all.forEach(function (child) {
      var dir = path.join(base, child)
      if (isDir(dir)) callback.call(null, dir)
    })
  })
}

// Delay function call and ignore invalid filenames
function normalizeCall(fname, opt, callback) {
  // Store each name of the modifying or temporary files generated by an editor
  fileNameCache.push(fname)
  runExclusive(function (done) {
    // When the write-to-file process is done, send all filtered filenames
    // to the callback function and call it
    fileNameCache.clear(function (name) {
      // Watch new created directory
      if (opt.recursive && !memo.has(name) && isDir(name))
        watch(callback, opt, name)
      callback(name)
    })
    done()
  })
}

function watch(callback, opt, fpath) {
  if (isSym(fpath) && !(opt.followSymLinks && opt.maxSymLevel--))
    return
  // Due to the unstable fs.watch(), if the `fpath` is a file then
  // switch to watch its parent directory instead of watch it directly.
  // Once the logged filename matches it then triggers the callback function
  if (isFile(fpath)) {
    var parent = path.resolve(fpath, '..')
    fs.watch(parent, opt, function (_, fname) {
      if (path.basename(fpath) === fname)
        normalizeCall(fpath, opt, callback)
    })
  } else if (isDir(fpath)) {
    fs.watch(fpath, opt, function (_, fname) {
      if (fname)
        normalizeCall(path.join(fpath, fname), opt, callback)
    })
    if (opt.recursive)
      getSubdirs(fpath, watch.bind(null, callback, opt))
  }
}

/**
 * Reliably watch nested files & directories (recursive by default)
 * @param {string|array} fpath Files or directories to watch
 * @param {object} [opt] Passed on to fs.watch()
 * @param {function} callback Invoked with a filename whenever there's a change
 */
module.exports = function watchVariadic(fpath, opt, callback) {
  if (typeof opt === 'function')
    callback = opt
  if (!isArray(fpath))
    fpath = [fpath]
  fpath.forEach(watch.bind(null, callback, assign({
    recursive: true,
    followSymLinks: false,
    maxSymLevel: 1
  }, opt)))
}
